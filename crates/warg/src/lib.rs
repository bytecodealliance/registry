use anyhow::Error;
use hash::HashParseError;
use prost::Message;
use signature::Error as SignatureError;
use signing::SignatureParseError;
use thiserror::Error;

pub mod hash;
pub mod operator;
pub mod package;
pub mod signing;

/// Types for converting to and from protobuf
pub mod protobuf {
    #![allow(clippy::all)]
    // Generated by [`prost-build`]
    include!(concat!(env!("OUT_DIR"), "/warg.rs"));
    // Generated by [`pbjson-build`]
    include!(concat!(env!("OUT_DIR"), "/warg.serde.rs"));

    pub fn prost_to_pbjson_timestamp(timestamp: prost_types::Timestamp) -> pbjson_types::Timestamp {
        pbjson_types::Timestamp {
            seconds: timestamp.seconds,
            nanos: timestamp.nanos,
        }
    }

    pub fn pbjson_to_prost_timestamp(timestamp: pbjson_types::Timestamp) -> prost_types::Timestamp {
        prost_types::Timestamp {
            seconds: timestamp.seconds,
            nanos: timestamp.nanos,
        }
    }
}

/// The envelope struct is used to keep around the original
/// bytes that the content was serialized into in case
/// the serialization is not canonical.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Envelope<Contents> {
    /// The content represented by content_bytes
    contents: Contents,
    /// The serialized representation of the content
    content_bytes: Vec<u8>,
    /// The hash of the key that signed this envelope
    key_id: signing::KeyID,
    /// The signature for the content_bytes
    signature: signing::Signature,
}

impl<Contents> Envelope<Contents> {
    /// Create an envelope for some contents using a signature.
    pub fn signed_contents(
        private_key: &signing::PrivateKey,
        contents: Contents,
    ) -> Result<Self, SignatureError>
    where
        Contents: Signable,
    {
        let content_bytes: Vec<u8> = contents.encode();

        let key_id = private_key.public_key().fingerprint();
        let signature = contents.sign(private_key)?;
        Ok(Envelope {
            contents,
            content_bytes,
            key_id,
            signature,
        })
    }

    /// Get the byte representation of the envelope contents.
    pub fn content_bytes(&self) -> &[u8] {
        &self.content_bytes
    }

    /// Get the representation of the entire envelope as a byte vector.
    /// This is the logical inverse of `Envelope::from_bytes`.
    pub fn to_bytes(&self) -> Vec<u8> {
        let proto_envelope = protobuf::Envelope {
            contents: self.content_bytes.clone(),
            key_id: self.key_id.to_string(),
            signature: self.signature.to_string(),
        };
        proto_envelope.encode_to_vec()
    }

    /// Create an entire envelope from a byte vector.
    /// This is the logical inverse of `Envelope::as_bytes`.
    pub fn from_bytes(bytes: Vec<u8>) -> Result<Self, ParseEnvelopeError>
    where
        Contents: Decode,
    {
        // Parse outer envelope
        let envelope = protobuf::Envelope::decode(bytes.as_slice())?;
        let contents = Contents::decode(&envelope.contents)?;

        // Read key ID and signature
        let key_id = envelope.key_id.into();
        let signature = envelope.signature.parse()?;

        Ok(Envelope {
            contents,
            content_bytes: envelope.contents,
            key_id,
            signature,
        })
    }
}

/// Errors that occur in the process of parsing an envelope from bytes
#[derive(Error, Debug)]
pub enum ParseEnvelopeError {
    #[error("Failed to parse the outer envelope protobuf message")]
    ProtobufEnvelopeParseError(#[from] prost::DecodeError),

    #[error("Failed to parse envelope contents from bytes")]
    ContentsParseError(#[from] Error),

    #[error("Failed to parse envelope key id")]
    KeyIDParseError(#[from] HashParseError),

    #[error("Failed to parse envelope signature")]
    SignatureParseError(#[from] SignatureParseError),
}

pub trait Signable: Encode {
    const PREFIX: &'static [u8];

    fn sign(
        &self,
        private_key: &signing::PrivateKey,
    ) -> Result<signing::Signature, SignatureError> {
        let prefixed_content = [Self::PREFIX, b":", self.encode().as_slice()].concat();
        private_key.sign(&prefixed_content)
    }

    fn verify(
        public_key: &signing::PublicKey,
        msg: &[u8],
        signature: &signing::Signature,
    ) -> Result<(), SignatureError> {
        let prefixed_content = [Self::PREFIX, b":", msg].concat();
        public_key.verify(&prefixed_content, signature)
    }
}

pub trait Decode: Sized {
    fn decode(bytes: &[u8]) -> Result<Self, Error>;
}

pub trait Encode {
    fn encode(&self) -> Vec<u8>;
}

/// Helper module for serializing and deserializing timestamps.
///
/// This is used over serde's built-in implementation to produce cleaner timestamps
/// in serialized output.
mod timestamp {
    use serde::Deserializer;
    use serde::{Deserialize, Serializer};
    use std::time::{Duration, SystemTime, UNIX_EPOCH};

    pub fn serialize<S>(timestamp: &SystemTime, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        use serde::ser::Error;

        let duration_since_epoch = match timestamp.duration_since(UNIX_EPOCH) {
            Ok(duration_since_epoch) => duration_since_epoch,
            Err(_) => return Err(S::Error::custom("timestamp must be later than UNIX_EPOCH")),
        };

        serializer.serialize_str(&format!(
            "{secs}.{nsecs}",
            secs = duration_since_epoch.as_secs(),
            nsecs = duration_since_epoch.subsec_nanos()
        ))
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<SystemTime, D::Error>
    where
        D: Deserializer<'de>,
    {
        use serde::de::Error;

        let s = String::deserialize(deserializer)?;
        let (secs, nsecs) = s
            .split_once('.')
            .ok_or_else(|| D::Error::custom("timestamp must be in the format <secs>.<nsecs>"))?;

        Ok(SystemTime::UNIX_EPOCH
            + Duration::new(
                secs.parse::<u64>().map_err(D::Error::custom)?,
                nsecs.parse::<u32>().map_err(D::Error::custom)?,
            ))
    }
}
